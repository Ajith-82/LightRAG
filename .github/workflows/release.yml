name: Release Automation

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
      draft:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.10'
  NODE_VERSION: '18'

jobs:
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      release_notes: ${{ steps.notes.outputs.release_notes }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate version format
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION=${GITHUB_REF#refs/tags/}
        fi
        
        # Validate version format (semantic versioning)
        if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?(\+[a-zA-Z0-9]+)?$ ]]; then
          echo "❌ Invalid version format: $VERSION"
          echo "Expected format: v1.2.3, v1.2.3-beta1, v1.2.3+build123"
          exit 1
        fi
        
        # Check if pre-release
        IS_PRERELEASE=false
        if [[ "$VERSION" =~ -[a-zA-Z] ]] || [[ "${{ github.event.inputs.prerelease }}" == "true" ]]; then
          IS_PRERELEASE=true
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        
        echo "✅ Version: $VERSION"
        echo "✅ Pre-release: $IS_PRERELEASE"

    - name: Check if tag exists (for workflow_dispatch)
      if: github.event_name == 'workflow_dispatch'
      run: |
        if git rev-parse "${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
          echo "❌ Tag ${{ steps.version.outputs.version }} already exists"
          exit 1
        fi

    - name: Verify CI status
      run: |
        # Check if CI passed for the commit we're releasing
        CI_STATUS=$(gh api \
          repos/${{ github.repository }}/actions/workflows/ci.yml/runs \
          --jq ".workflow_runs[0] | select(.head_sha == \"${{ github.sha }}\") | .conclusion" \
          || echo "unknown")
        
        if [[ "$CI_STATUS" != "success" ]]; then
          echo "❌ CI checks have not passed for this commit. Status: $CI_STATUS"
          echo "Cannot create release without passing CI checks."
          exit 1
        fi
        
        echo "✅ CI checks passed for commit ${{ github.sha }}"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate release notes
      id: notes
      run: |
        echo "📝 Generating release notes for ${{ steps.version.outputs.version }}"
        
        # Get previous tag
        PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        
        if [[ -n "$PREV_TAG" ]]; then
          echo "Previous release: $PREV_TAG"
          
          # Generate changelog since last tag
          CHANGELOG=$(git log ${PREV_TAG}..HEAD \
            --pretty=format:"- %s (%h)" \
            --grep="^feat:" --grep="^fix:" --grep="^docs:" --grep="^perf:" \
            --grep="^refactor:" --grep="^test:" --grep="^ci:" \
            --grep="^chore:" --grep="^style:" --invert-grep --grep="^Merge" \
            | head -50)
        else
          echo "No previous tag found, this is the first release"
          CHANGELOG="- Initial release"
        fi
        
        # Create release notes
        cat > release_notes.md << EOF
        ## What's Changed
        
        $CHANGELOG
        
        ## Installation
        
        \`\`\`bash
        pip install lightrag-hku==${{ steps.version.outputs.version }}
        \`\`\`
        
        ## Docker
        
        \`\`\`bash
        docker pull ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }}
        \`\`\`
        
        **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${{ steps.version.outputs.version }}
        EOF
        
        # Output for use in release
        echo 'release_notes<<EOF' >> $GITHUB_OUTPUT
        cat release_notes.md >> $GITHUB_OUTPUT
        echo 'EOF' >> $GITHUB_OUTPUT

  build-packages:
    name: Build Release Packages
    runs-on: ubuntu-latest
    needs: validate-release
    timeout-minutes: 20

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine wheel setuptools

    - name: Update version in code
      run: |
        VERSION="${{ needs.validate-release.outputs.version }}"
        VERSION_NUMBER=${VERSION#v}  # Remove 'v' prefix
        
        # Update __init__.py
        sed -i "s/__version__ = .*/__version__ = \"$VERSION_NUMBER\"/" lightrag/__init__.py
        
        # Update pyproject.toml if needed
        sed -i "s/version = .*/version = \"$VERSION_NUMBER\"/" pyproject.toml || true
        
        echo "Updated version to: $VERSION_NUMBER"

    - name: Build Python package
      run: |
        python -m build

    - name: Verify package
      run: |
        python -m twine check dist/*
        
        # Test install in clean environment
        python -m venv test_env
        source test_env/bin/activate
        pip install dist/*.whl
        python -c "import lightrag; print(f'LightRAG version: {lightrag.__version__}')"

    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: python-packages
        path: |
          dist/*.whl
          dist/*.tar.gz

  build-docker-release:
    name: Build Release Docker Images
    runs-on: ubuntu-latest
    needs: validate-release
    timeout-minutes: 30

    outputs:
      image_digest: ${{ steps.push.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository }}
        tags: |
          type=semver,pattern={{version}},value=${{ needs.validate-release.outputs.version }}
          type=semver,pattern={{major}}.{{minor}},value=${{ needs.validate-release.outputs.version }}
          type=semver,pattern={{major}},value=${{ needs.validate-release.outputs.version }},enable=${{ !needs.validate-release.outputs.is_prerelease }}
          type=raw,value=latest,enable=${{ !needs.validate-release.outputs.is_prerelease }}

    - name: Build and push release image
      id: push
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile.production
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ needs.validate-release.outputs.version }}
          BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          GIT_COMMIT=${{ github.sha }}

    - name: Generate image attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ghcr.io/${{ github.repository }}
        subject-digest: ${{ steps.push.outputs.digest }}
        push-to-registry: true

  test-release-packages:
    name: Test Release Packages
    runs-on: ubuntu-latest
    needs: [validate-release, build-packages, build-docker-release]
    timeout-minutes: 15

    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']

    steps:
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages
        path: dist/

    - name: Test wheel installation
      run: |
        python -m venv test_wheel
        source test_wheel/bin/activate
        pip install --upgrade pip
        
        # Install from wheel
        WHEEL_FILE=$(ls dist/*.whl | head -1)
        pip install "$WHEEL_FILE"
        
        # Basic import test
        python -c "
        import lightrag
        print(f'✅ LightRAG version: {lightrag.__version__}')
        
        # Test basic functionality
        from lightrag import LightRAG
        print('✅ LightRAG class imported successfully')
        "

    - name: Test source distribution
      run: |
        python -m venv test_sdist
        source test_sdist/bin/activate
        pip install --upgrade pip
        
        # Install from source distribution
        SDIST_FILE=$(ls dist/*.tar.gz | head -1)
        pip install "$SDIST_FILE"
        
        # Basic import test
        python -c "
        import lightrag
        print(f'✅ LightRAG version: {lightrag.__version__}')
        "

    - name: Test Docker image
      run: |
        VERSION="${{ needs.validate-release.outputs.version }}"
        
        # Pull and test the release image
        docker pull ghcr.io/${{ github.repository }}:$VERSION
        
        # Basic container test
        docker run --rm ghcr.io/${{ github.repository }}:$VERSION python -c "
        import lightrag
        print(f'✅ Docker - LightRAG version: {lightrag.__version__}')
        "

  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate-release, build-packages, build-docker-release, test-release-packages]
    timeout-minutes: 10

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages
        path: dist/

    - name: Create tag (for workflow_dispatch)
      if: github.event_name == 'workflow_dispatch'
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "${{ needs.validate-release.outputs.version }}" -m "Release ${{ needs.validate-release.outputs.version }}"
        git push origin "${{ needs.validate-release.outputs.version }}"

    - name: Create GitHub Release
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          const release = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: '${{ needs.validate-release.outputs.version }}',
            name: 'LightRAG ${{ needs.validate-release.outputs.version }}',
            body: `${{ needs.validate-release.outputs.release_notes }}`,
            draft: ${{ github.event.inputs.draft || false }},
            prerelease: ${{ needs.validate-release.outputs.is_prerelease }},
            generate_release_notes: false
          });
          
          console.log(`Created release: ${release.data.html_url}`);
          
          // Upload package files
          const globber = await glob.create('dist/*');
          const files = await globber.glob();
          
          for (const file of files) {
            const name = require('path').basename(file);
            const data = fs.readFileSync(file);
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.data.id,
              name: name,
              data: data
            });
            
            console.log(`Uploaded: ${name}`);
          }

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release]
    if: success() && !github.event.inputs.draft && github.repository == 'HKUDS/LightRAG'
    environment: pypi
    timeout-minutes: 10

    steps:
    - name: Download package artifacts
      uses: actions/download-artifact@v4
      with:
        name: python-packages
        path: dist/

    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_API_TOKEN }}
        verify-metadata: true

    - name: Verify PyPI publication
      run: |
        sleep 60  # Wait for PyPI to propagate
        
        VERSION="${{ needs.validate-release.outputs.version }}"
        VERSION_NUMBER=${VERSION#v}
        
        # Try to install from PyPI
        python -m venv verify_pypi
        source verify_pypi/bin/activate
        pip install --upgrade pip
        
        # Install specific version from PyPI
        pip install "lightrag-hku==$VERSION_NUMBER" --no-cache-dir
        
        python -c "
        import lightrag
        print(f'✅ Successfully installed from PyPI: {lightrag.__version__}')
        "

  update-documentation:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release]
    if: success() && !github.event.inputs.draft

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update documentation version references
      run: |
        VERSION="${{ needs.validate-release.outputs.version }}"
        VERSION_NUMBER=${VERSION#v}
        
        # Update README with new version
        if [ -f README.md ]; then
          sed -i "s/lightrag-hku==[0-9]\+\.[0-9]\+\.[0-9]\+/lightrag-hku==$VERSION_NUMBER/g" README.md
          sed -i "s/:v[0-9]\+\.[0-9]\+\.[0-9]\+/:$VERSION/g" README.md
        fi
        
        # Update CHANGELOG
        if [ -f CHANGELOG.md ]; then
          sed -i "1i\\## $VERSION ($(date +%Y-%m-%d))\\n\\n${{ needs.validate-release.outputs.release_notes }}\\n" CHANGELOG.md
        fi

    - name: Create documentation update PR
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "docs: update documentation for release ${{ needs.validate-release.outputs.version }}"
        title: "📚 Update documentation for release ${{ needs.validate-release.outputs.version }}"
        body: |
          Automated documentation update for release ${{ needs.validate-release.outputs.version }}.
          
          ## Changes
          - Updated version references in README.md
          - Updated CHANGELOG.md with release notes
          
          This PR was automatically created by the release workflow.
        branch: docs/release-${{ needs.validate-release.outputs.version }}
        delete-branch: true

  post-release:
    name: Post-release Tasks
    runs-on: ubuntu-latest
    needs: [validate-release, create-github-release, publish-pypi]
    if: always() && needs.create-github-release.result == 'success'

    steps:
    - name: Send release notification
      uses: actions/github-script@v6
      with:
        script: |
          const version = '${{ needs.validate-release.outputs.version }}';
          const isPrerelease = ${{ needs.validate-release.outputs.is_prerelease }};
          const pypiPublished = '${{ needs.publish-pypi.result }}' === 'success';
          
          let message = `🚀 **LightRAG ${version} Released!**\n\n`;
          
          if (isPrerelease) {
            message += '⚠️ This is a pre-release version.\n\n';
          }
          
          message += '## Installation\n\n';
          
          if (pypiPublished) {
            message += `\`\`\`bash\npip install lightrag-hku==${version.substring(1)}\n\`\`\`\n\n`;
          }
          
          message += '## Docker\n\n';
          message += `\`\`\`bash\ndocker pull ghcr.io/${{ github.repository }}:${version}\n\`\`\`\n\n`;
          
          message += '## Links\n\n';
          message += `- [Release Notes](https://github.com/${{ github.repository }}/releases/tag/${version})\n`;
          message += `- [Full Changelog](https://github.com/${{ github.repository }}/releases/tag/${version})\n`;
          
          if (pypiPublished) {
            message += `- [PyPI Package](https://pypi.org/project/lightrag-hku/${version.substring(1)}/)\n`;
          }
          
          // Create a discussion or issue about the release
          await github.rest.repos.createCommitComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            commit_sha: context.sha,
            body: message
          });

    - name: Update release metrics
      run: |
        echo "📊 Release Metrics for ${{ needs.validate-release.outputs.version }}:"
        echo "- GitHub Release: ${{ needs.create-github-release.result }}"
        echo "- PyPI Publication: ${{ needs.publish-pypi.result }}"
        echo "- Docker Images: ${{ needs.build-docker-release.result }}"
        echo "- Documentation: ${{ needs.update-documentation.result }}"
        
        # Here you could send metrics to analytics services
        # Example: DataDog, New Relic, custom metrics endpoint